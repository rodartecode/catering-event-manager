// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repository

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const checkConflicts = `-- name: CheckConflicts :many
SELECT
    rs.id,
    rs.resource_id,
    r.name as resource_name,
    rs.event_id,
    e.event_name,
    rs.task_id,
    t.title as task_title,
    rs.start_time as existing_start_time,
    rs.end_time as existing_end_time
FROM resource_schedule rs
JOIN resources r ON rs.resource_id = r.id
JOIN events e ON rs.event_id = e.id
LEFT JOIN tasks t ON rs.task_id = t.id
WHERE rs.resource_id = ANY($1::int[])
  AND tstzrange(rs.start_time, rs.end_time, '[)') && tstzrange($2::timestamptz, $3::timestamptz, '[)')
  AND ($4::int IS NULL OR rs.id != $4::int)
ORDER BY rs.resource_id, rs.start_time
`

type CheckConflictsParams struct {
	Column1           []int32       `json:"column_1"`
	Column2           time.Time     `json:"column_2"`
	Column3           time.Time     `json:"column_3"`
	ExcludeScheduleID sql.NullInt32 `json:"exclude_schedule_id"`
}

type CheckConflictsRow struct {
	ID                int32          `json:"id"`
	ResourceID        int32          `json:"resource_id"`
	ResourceName      string         `json:"resource_name"`
	EventID           int32          `json:"event_id"`
	EventName         string         `json:"event_name"`
	TaskID            sql.NullInt32  `json:"task_id"`
	TaskTitle         sql.NullString `json:"task_title"`
	ExistingStartTime time.Time      `json:"existing_start_time"`
	ExistingEndTime   time.Time      `json:"existing_end_time"`
}

// Find all existing schedule entries that overlap with the requested time range
// for any of the specified resources
func (q *Queries) CheckConflicts(ctx context.Context, arg CheckConflictsParams) ([]CheckConflictsRow, error) {
	rows, err := q.db.QueryContext(ctx, checkConflicts,
		pq.Array(arg.Column1),
		arg.Column2,
		arg.Column3,
		arg.ExcludeScheduleID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CheckConflictsRow
	for rows.Next() {
		var i CheckConflictsRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceID,
			&i.ResourceName,
			&i.EventID,
			&i.EventName,
			&i.TaskID,
			&i.TaskTitle,
			&i.ExistingStartTime,
			&i.ExistingEndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createScheduleEntry = `-- name: CreateScheduleEntry :one
INSERT INTO resource_schedule (resource_id, event_id, task_id, start_time, end_time, notes)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, resource_id, event_id, task_id, start_time, end_time, notes, created_at, updated_at
`

type CreateScheduleEntryParams struct {
	ResourceID int32          `json:"resource_id"`
	EventID    int32          `json:"event_id"`
	TaskID     sql.NullInt32  `json:"task_id"`
	StartTime  time.Time      `json:"start_time"`
	EndTime    time.Time      `json:"end_time"`
	Notes      sql.NullString `json:"notes"`
}

func (q *Queries) CreateScheduleEntry(ctx context.Context, arg CreateScheduleEntryParams) (ResourceSchedule, error) {
	row := q.db.QueryRowContext(ctx, createScheduleEntry,
		arg.ResourceID,
		arg.EventID,
		arg.TaskID,
		arg.StartTime,
		arg.EndTime,
		arg.Notes,
	)
	var i ResourceSchedule
	err := row.Scan(
		&i.ID,
		&i.ResourceID,
		&i.EventID,
		&i.TaskID,
		&i.StartTime,
		&i.EndTime,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteScheduleEntriesByTask = `-- name: DeleteScheduleEntriesByTask :exec
DELETE FROM resource_schedule
WHERE task_id = $1
`

func (q *Queries) DeleteScheduleEntriesByTask(ctx context.Context, taskID sql.NullInt32) error {
	_, err := q.db.ExecContext(ctx, deleteScheduleEntriesByTask, taskID)
	return err
}

const deleteScheduleEntry = `-- name: DeleteScheduleEntry :exec
DELETE FROM resource_schedule
WHERE id = $1
`

func (q *Queries) DeleteScheduleEntry(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteScheduleEntry, id)
	return err
}

const getResourceByID = `-- name: GetResourceByID :one
SELECT id, name, type, hourly_rate, is_available, notes, created_at, updated_at
FROM resources
WHERE id = $1
`

func (q *Queries) GetResourceByID(ctx context.Context, id int32) (Resource, error) {
	row := q.db.QueryRowContext(ctx, getResourceByID, id)
	var i Resource
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.HourlyRate,
		&i.IsAvailable,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getResourceSchedule = `-- name: GetResourceSchedule :many
SELECT
    rs.id,
    rs.resource_id,
    rs.event_id,
    e.event_name,
    rs.task_id,
    t.title as task_title,
    rs.start_time,
    rs.end_time,
    rs.notes,
    rs.created_at,
    rs.updated_at
FROM resource_schedule rs
JOIN events e ON rs.event_id = e.id
LEFT JOIN tasks t ON rs.task_id = t.id
WHERE rs.resource_id = $1
  AND rs.start_time >= $2
  AND rs.end_time <= $3
ORDER BY rs.start_time
`

type GetResourceScheduleParams struct {
	ResourceID int32     `json:"resource_id"`
	StartTime  time.Time `json:"start_time"`
	EndTime    time.Time `json:"end_time"`
}

type GetResourceScheduleRow struct {
	ID         int32          `json:"id"`
	ResourceID int32          `json:"resource_id"`
	EventID    int32          `json:"event_id"`
	EventName  string         `json:"event_name"`
	TaskID     sql.NullInt32  `json:"task_id"`
	TaskTitle  sql.NullString `json:"task_title"`
	StartTime  time.Time      `json:"start_time"`
	EndTime    time.Time      `json:"end_time"`
	Notes      sql.NullString `json:"notes"`
	CreatedAt  time.Time      `json:"created_at"`
	UpdatedAt  time.Time      `json:"updated_at"`
}

func (q *Queries) GetResourceSchedule(ctx context.Context, arg GetResourceScheduleParams) ([]GetResourceScheduleRow, error) {
	rows, err := q.db.QueryContext(ctx, getResourceSchedule, arg.ResourceID, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourceScheduleRow
	for rows.Next() {
		var i GetResourceScheduleRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceID,
			&i.EventID,
			&i.EventName,
			&i.TaskID,
			&i.TaskTitle,
			&i.StartTime,
			&i.EndTime,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduleEntryByID = `-- name: GetScheduleEntryByID :one
SELECT
    rs.id,
    rs.resource_id,
    rs.event_id,
    e.event_name,
    rs.task_id,
    t.title as task_title,
    rs.start_time,
    rs.end_time,
    rs.notes,
    rs.created_at,
    rs.updated_at
FROM resource_schedule rs
JOIN events e ON rs.event_id = e.id
LEFT JOIN tasks t ON rs.task_id = t.id
WHERE rs.id = $1
`

type GetScheduleEntryByIDRow struct {
	ID         int32          `json:"id"`
	ResourceID int32          `json:"resource_id"`
	EventID    int32          `json:"event_id"`
	EventName  string         `json:"event_name"`
	TaskID     sql.NullInt32  `json:"task_id"`
	TaskTitle  sql.NullString `json:"task_title"`
	StartTime  time.Time      `json:"start_time"`
	EndTime    time.Time      `json:"end_time"`
	Notes      sql.NullString `json:"notes"`
	CreatedAt  time.Time      `json:"created_at"`
	UpdatedAt  time.Time      `json:"updated_at"`
}

func (q *Queries) GetScheduleEntryByID(ctx context.Context, id int32) (GetScheduleEntryByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getScheduleEntryByID, id)
	var i GetScheduleEntryByIDRow
	err := row.Scan(
		&i.ID,
		&i.ResourceID,
		&i.EventID,
		&i.EventName,
		&i.TaskID,
		&i.TaskTitle,
		&i.StartTime,
		&i.EndTime,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listResources = `-- name: ListResources :many
SELECT id, name, type, hourly_rate, is_available, notes, created_at, updated_at
FROM resources
WHERE ($1::resource_type IS NULL OR type = $1::resource_type)
  AND ($2::boolean IS NULL OR is_available = $2::boolean)
ORDER BY name
LIMIT $4
OFFSET $3
`

type ListResourcesParams struct {
	Type        NullResourceType `json:"type"`
	IsAvailable sql.NullBool     `json:"is_available"`
	OffsetCount int32            `json:"offset_count"`
	LimitCount  int32            `json:"limit_count"`
}

func (q *Queries) ListResources(ctx context.Context, arg ListResourcesParams) ([]Resource, error) {
	rows, err := q.db.QueryContext(ctx, listResources,
		arg.Type,
		arg.IsAvailable,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Resource
	for rows.Next() {
		var i Resource
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.HourlyRate,
			&i.IsAvailable,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
